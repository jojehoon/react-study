### 설치
`npx create-react-app <appName> . --template typescript`
 
* `ReactDOM`
  * rootDOM의 render 역할
  * 브라우저에 있는 실제 DOM 내부에 React 컴포넌트를 렌더링
* APP 
 
React Fragment
별도의 Element를 생성하지 않음
 
 
### JSX 규칙
* 태그는 꼭 닫기
  * 두 개 이상의 태그는 무조건 하나의 태그로 감싸기
  * (Fragment <></> 브라우저 상에서 따로 별도의 엘리먼트로 나타나지 않음)
* JSX 내부에 자바스크립트 변수
  * {} 으로 감싸기
* JSX 에서 style 과 CSS class
  * 인라인 스타일은 객체 형태로 작성 & camelCase 형태로 네이밍
  * class는 className= 으로 설정
* 주석
  * `{/* 안보이는 주석 */}`
  * `/* 보이는 주석 */`
  * `// 인라인 주석`
 
 
### Props
* properties의 줄임말
* 여러개의 Props는 비구조화 할당으로 간결하게 작성
* 상위 컴포넌트에서 하위 컴포넌트로 데이터 전달
* `defaultProps`로 기본값 설정
* `props.children`으로 컴포넌트 태그 사이의 값을 조회
 
### 조건부 렌더링
* JSX 에서 null, false, undefined 를 렌더링하게 된다면 아무것도 나타나지 않음
* 보여주고 숨기고의 단순한 처리라면 && 연산자를 사용해서 처리
* props 이름만 작성하고 값을 생략한다면 `true`로 간주
 
 
### 함수형 컴포넌트에서 상태 관리
* `useState` Hooks 사용
  * 첫번째 원소는 현재 State
  * 두번째 원소는 Setter 함수
* 함수형 업데이트
  * Setter 함수의 인자로 함수를 전달
  * 컴포넌트 최적화 목적으로 사용
 
 
### Input 상태 관리
* 이벤트 핸들러에서 이밴트 객체를 매개변수로 받아와 사용
 
 
### 여러개의 input 상태 관리
* 객체를 수정할 때는 직접 수정 하면 안된다 (불변성)
* 새로운 객체를 만들어서 새로운 객체에 변화를 주고, 이를 상태로 사용한다
* 불변성을 지켜주어야만 리액트 컴포넌트에서 상태의 업데이트를 감지하고 필요한 리렌더링이 진행
  * `inputs[name] = value` 같은 기존 state를 직접 수정하면, 값을 바꿔도 리렌더링 되지 않음
* 리액트에서는 불변성을 지켜주어야만 컴포넌트 업데이트 성능 최적화가 가능

 
### useRef로 특정 DOM 선택
* `ref`로 DOM 접근
* 함수형 컴포넌트에서는 `ref` 사용시 `useRef` Hook 사용
* 클래스형 컴포넌트에서는 Callback 함수나 `React.createRef` 함수 사용
 
### 배열 렌더링하기
* 동적인 배열을 렌더링 할 때는 자바스크립트 배열 빌트인 함수 `map()` 사용
* 배열을 렌더링 할 때에는 `key` 라는 props 를 설정 (고유값)`key`
 * `key`는 배열의 상태가 업데이트의 최적화에 필요
 
### useRef로 컴포넌트 안의 변수 만들기
* `useRef` Hook으로 컴포넌트 안에서 조회 및 수정 할 수 있는 변수 관리
* `useRef`로 관리하는 변수는 값이 업데이트 되어도 컴포넌트가 리렌더링 되지 않음
* `useRef`로 관리하는 변수는 설정 후 바로 조회 가능
* 변수를 사용하여 다음과 같은 값을 관리
 * `setTimeout`, `setInterval` 을 통해 만들어진 id
 * 외부 라이브러리를 사용하여 생성된 인스턴스
 * scroll 위치
* `useRef`로 넘긴 인자가  `.current`의 기본값으로 설정
 * 수정할 때는 `.current` 값을 수정
 * 조회할 때는 `.current` 값을 조회
 
### 배열에 항목 추가
* 배열을 추가 할 때는 객체와 마찬가지로 불변성을 지켜야 한다
* `push`, `splice`, `sort`와 같은 함수를 사용하면 안된다
* `spread` 연산자나`concat` 함수를 사용하여 배열을 추가
 
### 배열에 항목 제거
* 배열의 항목을 제거할 때는 추가할 때와 마찬가지로 불변성을 지켜야 한다
* `filter` 함수 사용
 
### 배열 항목 수정
* 배열의 항목을 수정할 때는 불변성 유지
* `map` 함수 사용
 
### useEffect로 mount/unmount/update 설정
* `useEffect(func, [deps])`
* `useEffect`가 리턴하는 함수를 **cleanup 함수**라고 한다
* `uesEffect`에서 사용되는 의존값(state, props)가 있다면 `deps`에 넣어주는 것이 규칙
* `deps`에 의존값을 넣지 않는다면, `useEffect`에 등록한 함수가 실행 될 때 업데이트 된 의존값을 가르키지 않게 된다
 
* **deps 배열** 빈배열
 * 컴포넌트가 최초 마운트 되었을 때만 `useEffect`에 등록한 함수가 호출 (componentDidMount)
 * 컴포넌트가 사라질 때 cleanup 함수 호출 (componentWillUnmount)
* **deps 배열** 의존값
 * 컴포넌트가 최초 마운트 되었을 때 호출 (componentDidMount)
 * 의존값이 업데이트 되었을 때 호출 (componentDidUpdate)
 * 컴포넌트가 언마운트 때 호출, 값이 변경 되기 전에 호출 (componentWillUnmount)
* **deps 배열** 없음
 * 컴포넌트가 리렌더링 될 때 마다 호출
 
* Mount
 * `props`로 받은 값을 컴포넌트의 로컬 상태로 설정
 * 외부 API 요청 (RSET API 등)
 * 라이브러리 사용 (D3, Video.js 등...)
 * setInterval을 통한 반복작업 혹은 setTimeout을 통한 작업 예약
* Unmount
 * setInterval, setTimeout으로 등록한 작업들 초기화(clearInterval, clearTimeout)
 * 라이브러리 인스턴스 제거
 
 
### useMemo으로 연산한 값 재사용하기
* `useMemo(func, [deps])`
* 성능 최적화 목적으로 연산된 값응ㄹ `useMemo` Hook으로 재사용
* memo는 **memoized**의 약자로, 이전에 계산 한 값을 재사용 한다는 의미
* `useMemo(연산할 함수, 의존성 배열)`
 * 의존성 배열이 업데이트 될 때만 함수가 실행
 * 그렇지 않다면 이전의 값을 재사용
 
 
### useCallback으로 함수 재사용하기
* `useCallback(func, [deps])`은 함수를 새로 만들지 않고 재사용하고 싶을 때 사용
* `useCallback` 함수 안에서 사용되는 의존값이 있다면, 반드시 `deps` 배열에 포함
 * `deps` 배열에 의존값을 포함하지 않으면, `useCallback`에서 최신 의존값 참조를 보장해주지 않음
 * props로 받아온 함수가 있다면, 이 또한 `deps`로 지정
* `useCallback`은 `useMemo`을 기반으로 구성됨
 * `useMemo(() => () => { /**/ }, [deps])`
* 컴포넌트 렌더링 최적화 작업을 해주어야만 성능이 최적화
 
 
### React.memo로 컴포넌트 리렌더링 방지
* `React.memo(컴포넌트, propsAreEqaul(prevProps, nextProps) => ...)`는 컴포넌트의 props가 바뀌지 않는다면, 리렌더링을 방지하여 성능 최적화
* state 관리 시 함수형 업데이트를 하면 최신 state를 참조하기 때문에 `useCallback`의 `deps`에 의존값을 넣지 않아도 됨
* 렌더링 최적화를 하지 않을 컴포넌트에 사용하는 것은 불필요한 props만 비교 및 버그 야기
* `useCallback`, `useMemo`, `React.memo`는 컴포넌트의 성능을 실제로 개선할 수 있는 상황에서만 사용할 것
 
 
### userReducer로 state 업데이트 로직 분리
* state 관리 Hooks에는 `useState`와 `useReducer`가 있다
* `useReducer` Hook은 state 관리 로직을 컴포넌트에서 분리
* `reducer`란 현재 state와 action 객체(type 값을 가진)를 매개변수로 받아와서 새로운 state를 반환 해주는 함수
```
const reducer = (state, action) => {
 // 새로운 상태를 만드는 로직
 // const nextState = ...
 return nextState
}
```
* `const [state, dispatch] = useReducer(reducer, initialState)`
 * `dispatch({ type: 'SOME_NAME })`는 action을 발생시키는 함수
* `useState`의 setter를 여러번 사용해야 하는 일이 발생하면 `useReducer`를 고려
 
 
### Custom Hooks 만들기
* 반복되는 로직을 커스텀 Hooks로 만들어 재사용
* `src/hooks/`
* use라는 키워드로 시작하는 파일을 만들고 그 안에 함수를 작성
 
 
### Context API를 사용한 전역 값 관리
* `Context API`를 사용하여 state 혹은 값을 전역으로 관리
```
const UserDispatch = React.createContext(null)
<UserDispatch.Provider value={dispatch}>
 ...
</UserDispatch.Provier>
```
* `createContext`의 파라미터로 Context의 기본값 설정
* Context 사용할 때 값을 따로 지정하지 않을 경우 사용되는 기본 값
* `Context.Provider` 컴포넌트의 `value` 속성으로 Context의 값 지정
* `Provider`로 감싸진 컴포넌트 중 어디서든지 Context의 값을 조회 가능

